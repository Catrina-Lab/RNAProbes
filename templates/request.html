{% extends 'base.html' %}

{% block content %}
<div id="form-container">
  {% include 'request-form.html' %}
</div>
<div id="response-container" class="container d-none">
  <div class="text-center mb-5 text-header">
    <h1 class="display-5">Processing Your Requests</h1>
    <p class="lead text-muted">You can monitor the progress of each tool below.</p>
  </div>
  <div class="row justify-content-center">
    <div class="col-lg-8">
      {% for program in programs %}
        <div id="{{program}}-response-container">
          {% include 'request-failed.html' %}
          {% include 'request-received.html' %}
        </div>
      {% endfor %}
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='program-card.js') }}"></script>
<script>
  const form = document.querySelector("form");

  const responseContainer = document.getElementById("response-container");
  const formContainer = document.getElementById("form-container");
  const programs = {{ programs | tojson }};
  const defaultEndBaseMin = {{1 + exports.PinMol.probeMin}};
  const programsCased = Object.fromEntries(programs.map(e=>[e.toLowerCase(), e])); //easier than changing half the time (and maybe forgetting once)
  const resultUrls = {};

  form.addEventListener("submit", e => {
    e.preventDefault();
    if(formIsValid(e)){
      formContainer.classList.add("d-none");
      responseContainer.classList.remove("d-none");
      sendRequests();
    }
  });
  function formIsValid(){
    return true; //temp
  }
  const endBaseInput = form.querySelector("#pinmol-end-base");
  const endBaseText = form.querySelector("#pinmol-end-base-text");
  const startBaseInput = form.querySelector("#pinmol-start-base");
  const pinmolProbeLengthInput = form.querySelector("#pinmol-probe-length");
  form.addEventListener("input", e=>{
    if(e.target.id == "pinmol-probe-length" || e.target.id == "pinmol-start-base"){
      setProbeMin();
    }
  });

  function setProbeMin(){
    if(programsCased["pinmol"]){
      if(pinmolProbeLengthInput.value != ""){
        min = parseInt(pinmolProbeLengthInput.value) + (parseInt(startBaseInput.value) || 1);
        //endBaseInput.setAttribute("min", min);
        endBaseInput.min = min
        endBaseInput.textContent = min;
      } else {
        endBaseInput.min = defaultEndBaseMin;
        endBaseText.textContent = defaultEndBaseMin;
      }
    }
  }

  setProbeMin();

  document.addEventListener('click', e => {
    const downloadBtn = e.target.closest('[id$="-download-btn"]');
    if (downloadBtn) {
      const program = downloadBtn.id.split("-", 1)[0];
      downloadFile(program);
    }
  });

  function sendRequests() {
    programs.forEach(sendRequest);
  }

  async function sendRequest(program) {
    program = programsCased[program.toLowerCase()];
    const data = new FormData(form);
    const response = await fetch(`/send-request?program=${program}`, {
      method: "POST",
      body: data,
    });
    handleResponse(program, response);
  }
  async function handleResponse(program, response, isRecur = false){
    if(response.status >= 400  && response.status < 600){
      return handleError(program, response, await response.text())
    } else {
      const responseJson = await response.json();
      if(responseJson.status == "running") renderDelayedResponse(program, responseJson, isRecur);
      else renderResponse(program, responseJson);
    }
  }
  async function handleError(program, response, text){
    renderFail(program, text);
    if(response.status != 400) console.error(`Issue when submitting program ${program}: ${text}`);
    return text
  }
  function renderFail(program, text){
    programResponseContainer = document.getElementById(`${program}-response-container`);
    programResponseContainer.querySelector(".request-recieved").classList.add("d-none");
    programResponseContainer.querySelector(".request-failed").classList.remove("d-none");
    programResponseContainer.querySelector(".failed-message").textContent = text;
  }

  function renderResponse(program, response) {
    saveURL(program, response.zip);
    renderRecievedTemplate(program, response.html);
  }

  function saveURL(program, zip) {
    const zipFile = new Blob([base64ToUint8Array(zip)], { type: 'application/zip' });
    resultUrls[program] = URL.createObjectURL(zipFile);
  }

  function base64ToUint8Array(encoded) {
    const binary = atob(encoded);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < bytes.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  }

  function renderRecievedTemplate(program, html) {
    programResponseContainer = document.getElementById(`${program}-response-container`);
    requestRecieved = programResponseContainer.querySelector(".request-recieved");
    requestRecieved.classList.add("d-none");
    requestRecieved.insertAdjacentHTML("beforebegin", html); //add before request recieved for easy request swapping
  }

  function downloadFile(program) {
    const anchor = document.getElementById(`${program}-download-anchor`);
    if (anchor && resultUrls[program]) {
      anchor.href = resultUrls[program];
      anchor.click();
    }
  }

  async function renderDelayedResponse(program, responseJSON, isRecur = false){
    if(!isRecur) {
      renderRecievedTemplate(program, responseJSON.html);
      await sleep(250); //wait a little bit in for a failed program to be able to run
    } else await sleep(2 * 1000);
    queryResponse(program, responseJSON.id);
  }

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  async function queryResponse(program, id){
    response = await sendQuery(program, id);
    handleResponse(program, response, true);
  }

  async function sendQuery(program, id){
    return await fetch(`/query-result?program=${program}&id=${id}`)
  }
</script>
{% endblock %}

{% block head_content %}
<style>
  .program-section {
    background-color: #f8f9fa;
    padding: 1.5rem;
    border-radius: 10px;
    border: 1px solid #dee2e6;
  }
  .text-header{
    margin-top: 2rem;
  }
</style>
{% endblock %}