{% extends 'base.html' %}

{% block content %}
<div id="form-container">
  {% include 'request-form.html' %}
</div>
<div id="response-container" class="container d-none">
  <div class="text-center mb-5 text-header">
    <h1 class="display-5">Processing Your Requests</h1>
    <p class="lead text-muted">You can monitor the progress of each tool below.</p>
  </div>
  <div class="row justify-content-center">
    <div class="col-lg-8">
      {% for program in all_programs %}
        <div id="{{program}}-response-container" class="program-response-container d-none">
          {% include 'request-failed.html' %}
          {% include 'request-received.html' %}
        </div>
      {% endfor %}
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='program-card.js') }}"></script>
<script src="{{ url_for('static', filename='util.js') }}"></script>
<script>
  const programs = {{ all_programs | tojson }};
  const initialSelectedPrograms = {{programs | tojson}};
</script>
<script>
  const STATUS = createBasicEnum("STATUS", "RECIEVED", "DELAYED_RECIEVED", "COMPLETE", "FAILED");
  class ProgramQueryHandler{
    static selectedPrograms = Object.fromEntries(initialSelectedPrograms.map(e=>[e,true]));

    static getQueryHandlers(programs){
      const obj = Object.fromEntries(programs.map(e=>[e.toLowerCase(), new ProgramQueryHandler(e)]));
      Object.defineProperty(obj, "get", {
        value: e=>obj[e.toLowerCase()]
      })
      return obj;
    }
    static getSelectedPrograms(){
      return Object.keys(ProgramQueryHandler.selectedPrograms);
    }
    static isProgramSelected(program){
      return ProgramQueryHandler.selectedPrograms.hasOwnProperty(program);
    }
    static indexAttribute = "index";
    queries = [];
    currentQueryIndex = 0;
    constructor(program){
      this.program = program;  
      this.renderer = new QueryRenderer(program);
    }
    addResult(){
      const query = new Query(this.program, this.queries.length, this);
      this.queries.push(query);
      this.currentQueryIndex = this.queries.length - 1;
      this.render(query);
      return query;
    }
    render(query){
      this.renderer.render(query);
    }
    show(index, relative = false){
      if(relative) index = this.currentQueryIndex + index;
      this.currentQueryIndex = getWrapIndex(this.queries, index);
      this.renderer.render(this.queries[this.currentQueryIndex], true);
    }
    downloadFile(target){
      const container = target.closest(".single-query-container");
      const index = parseInt(container.getAttribute(ProgramQueryHandler.indexAttribute));
      const query = this.queries[index];
      query.downloadFile(container);
    }
    select(){
      const section = document.querySelector(`.program-section[program="${this.program}"]`);
      const button = document.querySelector(`.program-selector-button[program="${this.program}"]`);
      button.classList.remove("program-unselected");
      section.classList.remove("d-none");
      section.removeAttribute("disabled");
      ProgramQueryHandler.selectedPrograms[this.program] = true;
    }
    deselect(){
      const section = document.querySelector(`.program-section[program="${this.program}"]`);
      const button = document.querySelector(`.program-selector-button[program="${this.program}"]`);
      button.classList.add("program-unselected");
      section.classList.add("d-none");
      section.disabled = true;
      delete ProgramQueryHandler.selectedPrograms[this.program];
    }
  }

  class Query{
    value = "";
    url = "";
    constructor(program, index, parent){
      this.program = program;
      this.index = index;
      this.status = STATUS.RECIEVED;
      this.parent = parent;
    }
    downloadFile(container) {
      const anchor = container.querySelector(`.download-anchor`);
      if (anchor && this.url !== "") {
        anchor.href = this.url;
        anchor.click();
      } else if(anchor){
        throw new Error("Can't download file, no file to download");
      } else {
        throw new Error("Can't find anchor, something went wrong");
      }
    }
    render(value, queryStatus = STATUS.COMPLETE){
      this.value = value;
      this.status = queryStatus;
      this.parent.render(this);
    }
    async startResponse(response){
      return new QueryResponse(this, this.program).handleResponse(response);
    }
  }

  class QueryRenderer{
    static getQueryContainerID(query){
      return `${query.program}-result-container-${query.index}`;
    }

    currentRenderedQuery = null;
    program = "";
    constructor(program){
      this.program = program;  
      this.programResponseContainer = document.getElementById(`${program}-response-container`);
      this.recievedContainer = this.programResponseContainer.querySelector(".request-recieved");
      this.failedContainer = this.programResponseContainer.querySelector(".request-failed");    
    }
    render(query, showOnly = false){
      this.clearCurrent();
      if(query.status == STATUS.RECIEVED){
        this.currentRenderedContainer = this.showRecieved(query);
      } else if(query.status == STATUS.FAILED){
        this.currentRenderedContainer = this.showFailed(query);
      } else {
        this.currentRenderedContainer = this.renderQuery(query, showOnly);
      }
      this.programResponseContainer.classList.remove("d-none");
    }
    renderPaginationNumber(query, container){
      container.querySelector(".pagNum").textContent = query.index + 1;
    }
    showRecieved(query){
      this.renderPaginationNumber(query, this.recievedContainer);
      this.recievedContainer.classList.remove("d-none");
      return this.recievedContainer;
    }
    showFailed(query){
      this.renderPaginationNumber(query, this.failedContainer);
      this.failedContainer.classList.remove("d-none");
      this.failedContainer.querySelector(".failed-message").textContent = query.value;
      return this.failedContainer;
    }
    renderQuery(query, showOnly = false){
      const container = this.getOrCreateQueryContainer(query);
      container.classList.remove("d-none");
      if(!showOnly) container.innerHTML = this.parseQueryText(query);
      return container;
    }
    parseQueryText(query){
      const elem = document.createElement("template");
      elem.innerHTML = query.value;
      this.renderPaginationNumber(query, elem.content);
      return elem.innerHTML;
    }
    getOrCreateQueryContainer(query){
      const container = this.getSingleQueryContainer(query);
      return container || this.createQueryContainer(query);
    }
    createQueryContainer(query){
      return createElem("div", "single-query-container", this.programResponseContainer, elem=>{
        elem.id = QueryRenderer.getQueryContainerID(query);
        elem.setAttribute(ProgramQueryHandler.indexAttribute, query.index);
      });
    }
    getSingleQueryContainer(query){
      return this.programResponseContainer.querySelector("#" + QueryRenderer.getQueryContainerID(query));
    }
    clearCurrent(){
      if(this.currentRenderedContainer){
        this.currentRenderedContainer.classList.add("d-none");
      }
    }
  }

  function base64ToUint8Array(encoded) {
    const binary = atob(encoded);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < bytes.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  }
  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  class QueryResponse{
    constructor(query, program, response){
      this.query = query;
      this.program = program;
    }
    render(html, status = STATUS.COMPLETE){
      this.query.render(html, status);
    }
    async handleResponse(response){
      if(response.status >= 400  && response.status < 600){
        this.render(await response.text(), STATUS.FAILED)
      } else {
        const responseJson = await response.json();
        this.renderResponseJSON(responseJson);
      }
      return this;
    }
    renderResponseJSON(json){
      if(json.status == "running") this.renderDelayedResponse(json);
      else this.renderResponse(json);
    }
    renderResponse(json) {
      this.saveURL(json.zip);
      this.render(json.html);
    }
    saveURL(zip) {
      const zipFile = new Blob([base64ToUint8Array(zip)], { type: 'application/zip' });
      this.query.url = URL.createObjectURL(zipFile);
    }
    async renderDelayedResponse(json){
      if(this.query.status != STATUS.DELAYED_RECIEVED) {
        this.render(json.html, STATUS.DELAYED_RECIEVED);
        await sleep(250); //wait a little bit for a failed program to be able to run
      } else await sleep(2 * 1000);
      this.queryResponse(json.id);
    }
    async queryResponse(id){
      const response = await this.sendQuery(id);
      this.handleResponse(response, true);
    }

    async sendQuery(id){
      return await fetch(`/query-result?program=${this.program}&id=${id}`)
    }
  }
</script>
<script>
  const form = document.querySelector("form");

  const responseContainer = document.getElementById("response-container");
  const formContainer = document.getElementById("form-container");
  const programsCased = Object.fromEntries(programs.map(e=>[e.toLowerCase(), e])); //easier than changing half the time (and maybe forgetting once)

  const defaultEndBaseMin = {{1 + exports.PinMol.probeMin}};
  const resultUrls = {};
  const smFISHMaxSize = {{exports.smFISH.maxWebappSize}};
  const queryHandlers = ProgramQueryHandler.getQueryHandlers(programs);

  function programSelected(program){
    return ProgramQueryHandler.selectedPrograms[program.toLowerCase()];
  }
  form.addEventListener("submit", e => {
    e.preventDefault();
    if(formIsValid(form)){
      const programs = ProgramQueryHandler.getSelectedPrograms();
      sendRequests(programs);
      swapView(false, programs);
    }
  });
  function swapView(toForm = true, programs = []){
    if(toForm){
      formContainer.classList.remove("d-none");
      responseContainer.classList.add("d-none");
    } else {
      formContainer.classList.add("d-none");
      responseContainer.classList.remove("d-none");
      programs.forEach(e=>queryHandlers.get(e).deselect());
    }
  }
  function setScroll(){
    document.documentElement.style.setProperty("scroll-behavior", "auto", "important")
    setTimeout(()=>{
      document.documentElement.style.removeProperty("scroll-behavior");
    }, 50);
  }
  function invalidateForm(element, message){
    setScroll();
    element.setCustomValidity(message);
    element.reportValidity();
  }
  function formIsValid(form){
    const ctFileInput = form.querySelector("#ct-file");
    if(programSelected("smfish") && ctFileInput.files[0].size > smFISHMaxSize){
      invalidateForm(ctFileInput, `CT file too large! It must be below ${smFISHMaxSize / 1000 / 1000} MB if using smFISH. Please choose a smaller file, deselect smFISH, or run smFISH on your own system (view the github repository down below)`);
    } else {
        return true; //temp
    }
    return false;
  }
  const endBaseInput = form.querySelector("#pinmol-end-base");
  const endBaseText = form.querySelector("#pinmol-end-base-text");
  const startBaseInput = form.querySelector("#pinmol-start-base");
  const pinmolProbeLengthInput = form.querySelector("#pinmol-probe-length");
  form.addEventListener("input", e=>{
    if(e.target.id == "pinmol-probe-length" || e.target.id == "pinmol-start-base"){
      setProbeMin();
    }
  });

  function setProbeMin(){
    if(pinmolProbeLengthInput.value != ""){
      min = parseInt(pinmolProbeLengthInput.value) + (parseInt(startBaseInput.value) || 1);
      //endBaseInput.setAttribute("min", min);
      endBaseInput.min = min;
      endBaseInput.textContent = min;
    } else {
      endBaseInput.min = defaultEndBaseMin;
      endBaseText.textContent = defaultEndBaseMin;
    }
  }

  setProbeMin();

  document.addEventListener('click', e => {
    const btn = e.target.closest('button');
    if(!btn) return;
    if (btn.classList.contains("download-btn")) {
      const program = btn.getAttribute("program");
      queryHandlers.get(program).downloadFile(btn);
    } else if(btn.classList.contains("resubmit-btn")){
      const program = btn.getAttribute("program");
      queryHandlers.get(program).select();
      swapView();
    }
  });

  document.addEventListener('click', e => {
    if (e.target.classList.contains("pagArrow")) {
      program = e.target.parentNode.getAttribute("program");
      queryHandlers.get(program).show(parseInt(e.target.getAttribute("value")), e.target.getAttribute("relative") === "true");
    } else if(e.target.classList.contains("program-selector-button")){
      program = e.target.getAttribute("program");
      const selected = !e.target.classList.toggle("program-unselected");
      if(selected){
        queryHandlers.get(program).select();
      } else {
        queryHandlers.get(program).deselect();
      }
    }
  });

  function sendRequests(programs) {
    programs.forEach(sendRequest);
  }
  //******************************************************************************
  async function sendRequest(program) {
    program = programsCased[program.toLowerCase()];
    const data = new FormData(form);
    const query = queryHandlers[program.toLowerCase()].addResult();
    const response = await fetch(`/send-request?program=${program}`, {
      method: "POST",
      body: data,
    });
    query.startResponse(response);
  }
</script>
{% endblock %}

{% block head_content %}
<link rel="stylesheet" href="{{ url_for('static', filename='pagination.css') }}">
<style>
  .program-section {
    background-color: #f8f9fa;
    padding: 1.5rem;
    border-radius: 10px;
    border: 1px solid #dee2e6;
  }
  .text-header{
    margin-top: 2rem;
  }
</style>
{% endblock %}